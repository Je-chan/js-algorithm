# 1. 병합 정렬 / 합병 정렬 (Merge Sort)

- 병합 정렬은 전형적인 분할 정복 알고리즘

## 1-1) 분할 정복이란?

- 분할 정복은 다음의 로직으로 나뉜다

1. 분할 : 큰 문제를 작은 부분 문제(쉬운 문제)로 분할
2. 정복 : 작은 부분 문제를 각각 해결
3. 조합 : 해결한 문제의 답을 이용해 다시 큰 문제를 해결

- 분할 정복은 일반적으로 재귀 함수를 이용해 구현한다
  - 큰 문제를 작은 문제로 분할하는 방식이 동일한 경우가 많기 때문
  - 더는 쪼갤 수 없는 크기가 될 때까지 계속해서 분할
- 문제는 재귀함수를 사용하기에 함수 호출 횟수가 많이 발생
  - 스택 오버플로우가 발생할 수 있음
  - 함수의 정보가 계속 쌓이면서 오버헤드로 이어질 수 있음

## 1-2) 병합 정렬의 특징

- 시간 복잡도가 O(NlogN) 을 보장하는 빠른 정렬 알고리즘

## 1-3) 병합 정렬의 동작 방식

1. 분할 : 정렬할 배열을 같은 크기의 부분 배열 2개로 분할한다
2. 정복 : 부분 배열을 정렬한다
3. 조합 : 정렬된 부분 배열을 하나의 배열로 병합한다.

```jsx
// 정렬할 배열
[8, 4, 6, 1, 2, 5, 7, 3]

// STEP 1 : 분할
=> [8, 4, 6, 1], [2, 5, 7, 3]

// STEP 2 : 분할
=> [8, 4], [6, 1], [2, 5], [7, 3]

// STEP 3 : 분할
=> [8], [4], [6], [1], [2], [5], [7], [3]

// STEP 4 : 정복, 조합
=> [4, 8], [1, 6], [2, 5], [3, 7]

// STEP 5 : 정복, 조합
=> [1, 4, 8, 6], [2, 3, 5, 7]

// STEP 6 : 정복, 조합
=> [1, 2, 3, 4, 5, 6, 7, 8]

```

- 분할은 단순히 배열의 크기를 절반으로 쪼개는 것
- 정복은 두 개의 부분 배열을 정렬된 하나의 형태로 만드는 것
  - 각 부분 배열이 이미 정렬된 상태로 본다
  - 각 부분 배열에 대해 첫째 원소부터 시작해 하나씩 확인한다

```jsx
// 정복의 아이디어
// 비교 : [1, 4, 6, 8], [2, 3, 5, 7];
// 결과 : []

// STEP 1 : 각 배열에서 첫 번째 요소끼리 비교, 더 작은 값을 결과 배열에 넣는다
// 비교 : [4, 6, 8], [2, 3, 5, 7]
// 결과 : [1]

// STEP 2 : 또 각 배열에서 첫 번째 요소끼리 비교
// 비교 : [4, 6, 8], [3, 5, 7]
// 결과 : [1, 2]

// STEP 3 : 반복 수행
// 비교 : [4, 6, 8], [5, 7]
// 결과 : [1, 2, 3]

// ... 반복 수행
```

## 1-4) 병합 정렬의 시간 복잡도

- 직관적으로 생각했을 때, 높이가 O(logN) 이고 너비가 O(N) 인 정사각형과 유사하다
  - 높이는 절반씩 쪼개고 절반씩 합치는 과정
- 최악의 경우에 O(NlogN) 이 된다
- 장점 : 최악의 경우에도 O(NlogN) 의 시간복잡도
- 단점 : 일반적인 경우, 정복 과정에서 임시 배열이 필요하다
